编译原理第二次阶段报告

一．大体总结：

这周我的工作为学习目标代码生成部分的知识以及学习可视化界面的生成。三门课设堆在一起，时间紧任务重，最终可视化界面交给了能力更强的另一名组员完成，我和组长共同完成目标代码生成部分。在组长的耐心指导下我慢慢明白了这部分的大体逻辑，选择使用汇编形式的语言作为目标代码，期望对自己优化重组并产生的目标代码进行有效性和正确性验证，同时对编译器在整个计算机结构中的位置有了更好的理解。由于我的实际动手能力较差，到现在只编写出了一小部分代码，而组长那边已基本编写完毕，今天将进行所有分支最后的整合工作，整合完毕后来参加明天的验收。接下来展示一下我这周编写出来的关于目标代码生成部分的代码。

二．代码：

目标汇编程序的头部：将重组后四元式中用到的变量在符号表中的remark标记置为-1，生成目标代码时，只需要遍历符号表，对remark为-1的变量申请同名寄存器。

if  (baseqt[i].op == "main")

​		{

​			instruct ist1("DSEG", "SEGMENT");

​			OBJ.push_back(ist1);

 

​			for (int j = 0; j < synbl_list.size(); j++)

​			{

​				if ((synbl_list[j].mark == -1)&&(synbl_list[j].cat!="f"))

​				{

​					instruct ist(synbl_list[j].name, huibian_type(synbl_list[j].name)+" "+ to_string(huibian_size(huibian_type(synbl_list[j].name))) + " DUP(0)");

​					OBJ.push_back(ist);

​				}

​			}

​			instruct ist2("DSEG", "ENDS");

​			OBJ.push_back(ist2);

​			instruct ist8("SSEG", "SEGMENT STACK");

​			OBJ.push_back(ist8);

​			instruct ist9("STK", " DB  20 DUP(0)");

​			OBJ.push_back(ist9);

​			instruct ist10("SSEG", "ENDS");

​			OBJ.push_back(ist10);

​			instruct ist3("CSEG", "SEGMENT");

​			OBJ.push_back(ist3);

​			instruct ist4("ASSUME", "CS:CSEG");

​			OBJ.push_back(ist4);

​			instruct ist5("ASSUME", "DS:DSEG");

​			OBJ.push_back(ist5);

​			instruct ist6("MOV","AX","DSEG");

​			ist6.label = "START:";

​			OBJ.push_back(ist6);

​			instruct ist7("MOV", "DS", "AX");

​			OBJ.push_back(ist7);

对于子程序的头部，需要主程序和子程序的定义伪指令PROC xx NEAR,以及相应的现场保护程序：

else if ((baseqt[i].op1.name != "main") && (search_type(baseqt[i].op) == "f"))

​		{

​			instruct ist1(baseqt[i].op, "PROC NEAR");

​		OBJ.push_back(ist1);

​		instruct ist2("PUSH", "AX");

​		OBJ.push_back(ist2);

​		}

​		else if (baseqt[i].op == "goto")

​		{

​		instruct ist1("CALL",baseqt[i].op1.name);

​		OBJ.push_back(ist1);

​		}

目标汇编程序的尾部return指令：1）对于被调用的函数而言，在汇编语言中使用子程序来实现，需要用到堆栈段来保护现场，由于只考虑了单寄存器，仅需要将AX内容压栈保护即可：

else if ((baseqt[i].op == "return") && (search_type(baseqt[i].op2.name) == "f")&&( baseqt[i].op2.name!="main"))

​		{

​			if ((RDL != "0") && (search_active(RDL, baseqt.size(), baseqt) == 'y'))

​			{

​				instruct ist1("MOV", RDL, "AX");

​				cout << ist1.num << " " << ist1.op << " " << ist1.oprd1 << " " << ist1.oprd2 << endl;

​				OBJ.push_back(ist1);

​			}

​			RDL = "0";

​			instruct ist1("POP", "AX");

​			cout << ist1.num << " " << ist1.op << " " << ist1.oprd1 << endl;

​			OBJ.push_back(ist1);

​			instruct ist2("RET");

​			cout << ist2.num << " " << ist2.op << endl;

​			OBJ.push_back(ist2);

​			instruct ist3(baseqt[i].op2.name,"ENDP");

​			cout << ist3.num << " " << ist3.op << " " << ist3.oprd1 << endl;

​			OBJ.push_back(ist3);

​		}

2）对于main主函数而言，需要运行结束将4C00H放入AX，并以INT 21结束。

else if ((baseqt[i].op == "return")&& (baseqt[i].op2.name == "main"))

​		{

​			if ((RDL != "0") && (search_active(RDL, baseqt.size(), baseqt) == 'y'))

​			{

​				instruct ist1("MOV", RDL, "AX");

​				OBJ.push_back(ist1);

​			}

​			RDL = "0";

​			instruct ist0("MOV", "AX","4C00H");

​			OBJ.push_back(ist0);

​			instruct ist1("INT", "21H");

​			OBJ.push_back(ist1);

​		}

MUL和DIV不能为立即数指令目标代码的生成：选择额外寄存器来过渡一下，先将立即数送入TEMP中，再执行MUL TEMP指令。

if ((baseqt[i].op == "+") || (baseqt[i].op == "-") || (baseqt[i].op == ">") || (baseqt[i].op == "<"))

​				{

​					string str;

​					if (baseqt[i].op == "+")

​						str = "ADD";

​					else if (baseqt[i].op == "-")

​						str = "SUB";

​					else if ((baseqt[i].op == ">") || (baseqt[i].op == "<"))

​						str = "CMP";

​					instruct ist2(str, "AX", baseqt[i].op2.name);

​					OBJ.push_back(ist2);

​				}

​				if ((baseqt[i].op == "*") || (baseqt[i].op == "/"))

​				{

​					string str;

​					if (baseqt[i].op == "*")

​						str = "MUL";

​					else if (baseqt[i].op == "/")

​						str = "DIV";

​					if (isconst(baseqt[i].op2.name))

​					{

​						instruct ist2("MOV", "TEMP" + to_string(tempnum), baseqt[i].op2.name);

​						OBJ.push_back(ist2);

​						instruct ist3(str, "TEMP" + to_string(tempnum));

​						OBJ.push_back(ist3);

​						instruct ist4("TEMP" + to_string(tempnum), "DB 4 DUP(0)");

​						OBJ.insert(OBJ.begin() + 1, ist4);

​						synbl s;

​						s.name = "TEMP" + to_string(tempnum);

​						s.mark = -1;

​						synbl_list.push_back(s);

​						tempnum++;

​					}

​					else

​					{

​						instruct ist4(str, baseqt[i].op2.name);

​						OBJ.push_back(ist4);

​					}

​				}

 

三．遇到的问题及解决办法：

（1）指令语法需要的额外寄存器

在汇编语言中，MUL和DIV指令不支持立即数的运算，需要添加一条放到寄存器中的指令，而且不能是AX，我采取的是另外开辟TEMP i来实现

（2）头部生成时开辟空间的寄存器的选择

在符号表中为每个元素添加一个remark标记位，在四元式重组时对涉及到的变量修改符号表中的remark标志位，在目标代码生成时，看符号表中每个元素的remark位是否为-1即可。

 

四．接下来的工作安排：

编译原理课设已接近尾声，今明两天将进行最后的收尾工作，在完成明天的答辩与验收之后，我们组将认真完成报告内容，对本次编译原理进行一个圆满的收尾工作。

五．心得与体会：

这两周的编译原理课设使我收获满满。首先是我们组对文法的敲定，在设计过程中，我们既要考虑了从程序员角度看到的程序格式，也要考虑机器使用文法的便捷性，这个过程花费了我们比较长的时间，文法也在根据需要一直在修改和扩充，直到这个文法可以识别我们熟悉的代码格式。我的动手能力也得到了锻炼，之前在实验课上只是写两个相对简单的功能，并不用考虑整体性，而这次对于我来说着实是一个非常大的挑战。这两周是忙碌的，也是充实的，我非常感谢对我耐心答疑的老师和帮助过我的同学，也非常感谢队友们能包容我这个能力不是很好的小垃圾，队友们就是我可靠的后背，会在我进展不顺利非常焦虑的时候鼓励我、开导我，会在我遇到困难时帮助我，因为他们，这两周我的编译课设之旅收获满满。