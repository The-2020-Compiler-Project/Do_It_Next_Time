编译原理第一次阶段报告

一．大体总结：

本次实验我首先负责的是语法分析的部分，我们组经共同商讨，把此次课设的文法确定了下来，并决定采用递归下降子程序法进行语法分析。首先我理解了文法的具体流程，把代码的大体思路构建出来。收到于永勋写完的接口后，我就可以开始我这部分的语法分析了。由于我的编程能力相对较弱，在编写函数部分的代码停滞了一两天，我的组长以及另一位组员也给予了我非常大的帮助，非常细心地为我讲解，这一周我也将语法分析部分的函数声明、变量声明以及赋值语句写完了，以下是我这部分的代码：

二．代码：

  int program()// 程序

  {

​    out_statement();

  }

  int out_statement()//外部声明

  {

​    func_def();

  }

  int func_def()//函数定义

  {

 

​    if (!p->a.compare("i"))//是否为标识符

​    {

 

​    }

​    else exit(0);

​    if (p[p->num] != '(')

​      exit(0);

​    //函数声明();

​    p = p->next;

​    if (p[p->num] != ')')

​      exit(0);

​    p = p->next;

​    if (p[p->num] != '{')

​      exit(0);

​    p = p->next;

​    complex_sentence();

​    if (p[p->num] != '}')

​      exit(0);

  }

  int type_explanation()//类型说明

  {

​    int n;

​    a->prior = a;

​    a = a->next;

​    a->next = NULL;

​    a = new SYNBL;

​    s.push_back(a);

​    if (p->a == "k")

​    {

​      if (!strcmp("void", k[p->num]))

​        n=1;      

​      else if (!strcmp("int", k[p->num]))

​        n=2;      

​      else if (!strcmp("char", k[p->num]))

​        n=3;      

​      else if (!strcmp("float", k[p->num]))

​        n=4;

​      switch(n)

​      case 1:

​      case 2:

​      case 3:

​      case 4:

​      defaul: return 0;

​      p=p->next;

​      return 1;

​    }

​    else 

​      exit(0);

  }

  int complex_sentence()//复合语句

  {

​    if (!sentence_list());

​    {

​      if (!statement_list())

​        exit(0);

​      if (!sentence_list())

​        return 0;

​    }

​    return 1;

  }

  int sentence_list()//语句列表

  {

​    sentence();

  }

  int statement_list()//声明列表

  {

​    if (!type_explanation())

​      return 0;

​    statement();

​    if (p().compare(";")!=0)

​      exit(0);

​    statement_list1();//是否要return

  }

  int statement_list1()//声明列表1

  {

​    if (!statement_list())

​      return 0;

  }

  int statement()//声明

  {

​    if (!direct_description())

​      return 0;

​    return 1;

  }

  int direct_description()//直接说明符

  {  

​    if (p->a.compare("i") != 0) //不是标识符

​      exit(0);

 

​    if (!direct_description1());

​      return 0;

​    return 1;

  }

  int direct_description1()//直接说明符1

  {

​    if (!p().compare("["))

​    {

​      //s.back()->typ = a->prior->typ;

​      //s.back()->name=p();填写符号表变量名，需要vector，但是似乎不用在这里填写

​      //填写数组表

​      if (!常数表达式)//没有定义大小

​        exit(0);

​      if (!p().compare("]"))

​        exit(0);

​      if (!direct_description1())

​        return 0;

​      else

​        return 1;

​    }

​    if (!p().compare(","))//下一个字符为,

​    {

​      //开辟总表下一个空间和vector下一空间

​      

​      //准备填表

​      if (p->a.compare("i") != 0) //不是标识符

​        exit(0);

​      //如果是标识符     

​      if (!direct_description1())

​        return 0;

​      else

​        return 1;

​    }

​    return 0;     

  }

  int sentence()//语句

  {

​    if (complex_sentence() || express() )

​      return 1

​    else

​      return 0;

  }

  int express()//表达式

  {

​    assignment()

  }

  int assignment()//赋值表达式

  {

​    if (PLUS())

​      return 1;

​    if (!BASE())

​      return 0;

​    if (!数值操作符())

​      return 0;

​    if (!assignment())

​      return 0;

​    return 1;

  }

  int PLUS()

  {

​    if (!TIMES())

​      return 0;

​    if (!PLUS1())

​      return 0;

​    return 1;

  }

  int PLUS1()

  {

​    if ('+')

​    {

​      if (!TIMES())

​        exit(0);

​      if (!PLUS1())

​        exit(0);

​      return 1;

​    }

​    else if ('-')

​    {

​      if (!TIMES())

​        exit(0);

​      if (!PLUS1())

​        exit(0);

​      return 1;

​    }

​    else return 1;

  }

  int TIMES()

  {

​    if (!BASE())

​      return 0;

​    if (!TIMES1())

​      return 0;

​    return 1;

  }

  int TIMES1()

  {

​    if ('*')

​    {

​      if (!BASE())

​        exit(0);

​      if (!TIMES1())

​        exit(0);

​      return 1;

​    }

​    else if ('/')

​    {

​      if (!BASE())

​        exit(0);

​      if (!TIMES1())

​        exit(0);

​      return 1;

​    }

​    else if ('%')

​    {

​      if (!BASE())

​        exit(0);

​      if (!TIMES1())

​        exit(0);

​      return 1;

​    }

​    else return 1;

  }

  int BASE()

  {

​    if (标识符())

​      return 1;

​    if (常量())

​      return 1;

​    if (字符串())

​      return 1;

​    if ('(')

​    {

​      if (!表达式())

​        exit(0);

​      if (!')')

​        exit(0);

​    }

​    return 0;

}

三．遇到的问题及解决办法：

首先拿到语法分析这一任务时，首先联想起了本次编译原理实验课的内容，参考了上次自己所写的实验题目，再根据此次新的文法进行加工和处理。由于文法进行了很大的改动，此次编译器的文法要复杂很多，刚开始做的时候总是很难理清各个函数之间的联系，后来组长以及其他组员与我进行共同探讨，给予了我非常大的帮助，使我茅塞顿开，将部分文法进行修理以及完善之后，顺利地开展了我这部分的工作。

四．接下来的工作安排：

在接下来的一周里我会继续学习中间代码和目标代码的生成部分的知识，同时根据个人以及小组的情况写一下可视化界面部分的代码，尽量在实现编译器功能的同时，也能将编译器做得好看一些，美观一些。

五．心得与体会：

这周的编译原理课设过程虽然辛苦，但我从中收获了很多，对书本上的知识、编译器真正的实现过程有了更深的理解。早在开学之初，老师就已经向我们阐述了编译原理课设的重要性与难度，事实证明，老师所言极是。虽然在课设开始前就有实验课打基础，但是只是课设过程中一个很小的部分，功能也并不完善。在之前的编程中，我只是按照既定的语法来编辑程序，并不清楚语法存在的意义，对“编译器”这个名词也只是有一个模糊的概念。而通过这个学期编译原理的学期，我明白了原来源程序要想真正转换为机器可以认识的目标代码，其实是需要相当复杂的一个过程的。在接下来的一周中我也会继续努力，争取出色完成任务。

