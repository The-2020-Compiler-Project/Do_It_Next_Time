#include<iostream>
#include<vector>
#include<algorithm>
#include<stdio.h>
#include<string>
#include<string.h>
using namespace std;
#define _CRT_SECURE_NO_DEPRECATE
#define _CRT_SECURE_NO_WARNINGS
#pragma warning(disable:4996)
int sentence_list1();
int program();
int out_statement();
int func_def();
int type_explanation();
int complex_sentence();
int sentence_list();
int statement_list();
int statement_list1();
int statement();
int direct_description();
int direct_description1();
int sentence();
int give();
int PLUS();
int PLUS1();
int TIMES();
int TIMES1();
int BASE();

int pw(string b);
typedef struct excel excel, * linklist;
typedef struct PFINFL* PF;
typedef struct SYNBL* SY;
typedef struct TAPEL* TA;
typedef struct AINFL* AI;
struct excel//存储输出token序列的结构体
{
    string a;
    int num;
    excel* next;
};
excel* p; //token串头指针

typedef struct SYNBL //符号表总表
{
    string name;
    string typ;
    string cat;
    int  addr[2];//变量的地址
    PF p=NULL;//函数表的地址
    TA t=NULL;     //类型表，有数组时需要填
    int consl;   //常量的值
    int length;  //数组的长度
    struct SYNBL* next=NULL, * prior=NULL;
} SYNBL, * SY;
void print();
typedef struct PFINFL //函数表
{
    int Level;  //函数在第几层
    int Off;    //区距
    int Fn;     //变量数
    SY Param;   //每个函数对应的变量的信息
    //addr；      //入口地址
        struct PFINFL* next;
} PFINFL, * PF;

typedef struct TAPEL //类型表
{
    char type; //类型
    AI p;   //如果是数组型就继续填数组表
    struct TAPEL* next;
} TAPEL, * TA;

typedef struct AINFL //数组表
{
    int low; //数组下界
    int up;  //数组上界
    AI a; //填写单元类型
    int clen; //每个单元占的长度
    struct AINFL* next;
} AINFL, * AI;
typedef struct queen
{
    SYNBL* first;
    SYNBL* last;
}queen,*QU;
vector <SY> s;
vector <PF> pf;
vector <char> cal;
SYNBL* a;//初始化前后指针
PFINFL* b;
int lv = 1; //函数层数
int is_icon();
excel* Lexical_analysis(FILE* f);
char key[17][20] = { "int", "main", "void", "if", "else", "char", "scanf", "printf", "break", "float""for", "return", "switch", "case", "continue", "do", "while" }; //关键字
char pa[20][20] = { "+", "-", "*", "/", "{", "}", ",", ";", "(", ")", "[", "]", ">=", ">", "<=", "<", "==", "=", "&", "||" }; //界符
char i[100][20];//标识符
char con[100][20];//常数
char str[100][20];//字符串
char c[100];//字符
char buf, x;
char token[200];
int main(void)
{
    SYNBL* heada ;
    heada = new SYNBL;
    heada = a;
    FILE* file = fopen("C:/Users/machenike/Desktop/test.txt", "r");
    if (file == NULL)
    {
        cout << "read source file failed!" << endl;
        return -1;
    }//判断读取文件是否成功
    p = Lexical_analysis(file);
    if (program())
        cout << "编译成功" << endl;
    print();
    fclose(file);
    return 0;
}
excel*  Lexical_analysis(FILE* f)
{
    excel* head, * ps;
    head = new excel;
    ps = head;
    int m = 0, n = 0, c1 = 0, c2 = 0, con1 = 0, con2 = 0, str1 = 0, str2 = 0, i1 = 0, i2 = 0;
    int temp = 0;
    while ((buf = fgetc(f)) != EOF) {
        excel* s = new excel;
        if (buf == ' ' || buf == '\t' || buf == '\n') {}

        else if (((buf >= 'a') && (buf <= 'z')) || ((buf >= 'A') && (buf <= 'Z')))
        {
            m = 0; temp = 0;
            while (((buf >= 'a') && (buf <= 'z')) || ((buf >= 'A') && (buf <= 'Z')) || ((buf >= '0') && (buf <= '9')) || buf == '_')
            {

                token[m++] = buf;
                buf = fgetc(f);
            }
            token[m++] = '\0';
            fseek(f, -1, SEEK_CUR); //零点为当前指针位置
            for (n = 0; n < 17; n++)
                if (strcmp(token, key[n]) == 0)
                {
                    s->a = "k";
                    s->num = n;
                    ps->next = s;
                    ps = s;
                    cout << "<k," << n << ">  " << key[n] << endl;
                    break;
                }
            if (n == 17)
            {
                for (i1 = 0; i1 < i2; i1++)
                {
                    if (strcmp(token, i[i1]) == 0)
                    {
                        temp = 1;
                        s->a = "i";
                        s->num = i1;
                        ps->next = s;
                        ps = s;
                        cout << "<i," << i1 << ">  " << i[i1] << endl;
                        break;
                    }
                }
                if (temp == 0)
                {
                    strcpy(i[i2], token);
                    s->a = "i";
                    s->num = i2;
                    ps->next = s;
                    ps = s;
                    cout << "<i," << i2 << ">  " << i[i2] << endl;
                    i2++;
                }
            }

        }
        else if ((buf >= '0') && (buf <= '9')) // 判断是否为算数常数
        {
            m = 0; temp = 0;
            while (((buf >= '0') && (buf <= '9')) || buf == '.')
            {

                token[m++] = buf;
                buf = fgetc(f);
            }
            token[m++] = '\0';
            fseek(f, -1, SEEK_CUR);
            for (con1 = 0; con1 < con2; con1++)
            {
                if (strcmp(token, con[con1]) == 0)
                {
                    temp = 1;
                    s->a = "con";
                    s->num = con1;
                    ps->next = s;
                    ps = s;
                    cout << "<con," << con1 << ">  " << con[con1] << endl;
                    break;
                }
            }
            if (temp == 0)
            {
                strcpy(con[con2], token);
                s->a = "con";
                s->num = con2;
                ps->next = s;
                ps = s;
                cout << "<con," << con2 << ">  " << con[con2] << endl;
                con2++;
            }

        }
        else if (buf == '\'') //判断是否为字符
        {
            buf = fgetc(f);
            x = buf; temp = 0;
            for (c1 = 0; c1 < c2; c1++)
            {
                if (x == c[c1])
                {
                    temp = 1;
                    s->a = "c";
                    s->num = c1;
                    ps->next = s;
                    ps = s;
                    cout << "<c," << c1 << ">  " << c[c1] << endl;
                }
            }
            if (temp == 0)
            {
                c[c2] = x;
                s->a = "c";
                s->num = c2;
                ps->next = s;
                ps = s;
                cout << "<c," << c2 << ">  " << c[c2] << endl;
                c2++;
            }

            while (buf != '\'')
            {
                buf = fgetc(f);
            }
        }
        else if (buf == '"') //判断是否为字符串
        {
            buf = fgetc(f);
            m = 0; temp = 0;
            while (buf != '"')
            {
                token[m++] = buf;
                buf = fgetc(f);

            }
            token[m++] = '\0';
            for (str1 = 0; str1 < str2; str1++)
            {
                if (strcmp(token, str[str1]) == 0)
                {
                    temp = 1;
                    s->a = "string";
                    s->num = str1;
                    ps->next = s;
                    ps = s;
                    cout << "<string," << str1 << ">  " << str[str1] << endl;
                    break;
                }
            }
            if (temp == 0)
            {
                strcpy(str[str2], token);
                s->a = "string";
                s->num = str2;
                ps->next = s;
                ps = s;
                cout << "<string," << str2 << ">  " << str[str2] << endl;
                str2++;
            }
        }
        else switch (buf)   //查界符表
        {
        case '+': cout << "<p,0>  " << pa[0] << endl; s->a = "p"; s->num = 0;  ps->next = s; ps = s; break;
        case '-': cout << "<p,1>  " <<  pa[1] << endl; s->a = "p"; s->num = 1; ps->next = s; ps = s; break;
        case '*': cout << "<p,2>  " << pa[2] << endl; s->a = "p"; s->num = 2; ps->next = s; ps = s; break;
        case '/': cout << "<p,3>  " << pa[3] << endl; s->a = "p"; s->num = 3; ps->next = s; ps = s; break;
        case '{': cout << "<p,4>  " << pa[4] << endl; s->a = "p"; s->num = 4; ps->next = s; ps = s; break;
        case '}': cout << "<p,5>  " << pa[5] << endl; s->a = "p"; s->num = 5; ps->next = s; ps = s; break;
        case ',': cout << "<p,6>  " << pa[6] << endl; s->a = "p"; s->num = 6; ps->next = s; ps = s; break;
        case ';': cout << "<p,7>  " << pa[7] << endl; s->a = "p"; s->num = 7; ps->next = s; ps = s; break;
        case '(': cout << "<p,8>  " << pa[8] << endl; s->a = "p"; s->num = 8; ps->next = s; ps = s; break;
        case ')': cout << "<p,9>  " <<  pa[9] << endl; s->a = "p"; s->num = 9; ps->next = s; ps = s; break;
        case '[': cout << "<p,10>  " <<  pa[10] << endl; s->a = "p"; s->num = 10; ps->next = s; ps = s; break;
        case ']': cout << "<p,11>  " << pa[11] << endl; s->a = "p"; s->num = 11; ps->next = s; ps = s; break;
        case '&': cout << "<p,18>  " << pa[18] << endl; s->a = "p"; s->num = 18; ps->next = s; ps = s; break;
        case '>':
        {
            buf = fgetc(f);
            if (buf == '=')
            {
                cout << "<p,12>  " << pa[12] << endl;
                s->a = "p"; s->num = 12;
                ps->next = s;
                ps = s;
            }
            else
            {
                fseek(f, -1, SEEK_CUR);
                cout << "<p,13>  " << pa[13] << endl;
                s->a = "p"; s->num = 13;
                ps->next = s;
                ps = s;
            }
        }
        break;
        case '<':
        {
            buf = fgetc(f);
            if (buf == '=')
            {
                cout << "<p,14>  " << pa[14] << endl;
                s->a = "p"; s->num = 14;
                ps->next = s;
                ps = s;
            }
            else
            {
                fseek(f, -1, SEEK_CUR);
                cout << "<p,15>  " << pa[15] << endl;
                s->a = "p"; s->num = 15;
                ps->next = s;
                ps = s;
            }
        }
        break;
        case '=':
        {
            buf = fgetc(f);
            if (buf == '=')
            {
                cout << "<p,16>  " << pa[16] << endl;
                s->a = "p"; s->num = 16;
                ps->next = s;
                ps = s;
            }
            else
            {
                fseek(f, -1, SEEK_CUR);
                cout << "<p,17>  " << pa[17] << endl;
                s->a = "p"; s->num = 17;
                ps->next = s;
                ps = s;
            }
        }
        break;
        case '|':
        {   buf = fgetc(f);
        if (buf == '|')
        {
            cout << "<p,19>  " << pa[19] << endl;
            s->a = "p"; s->num = 19;
            ps->next = s;
            ps = s;
        }
        } break;
        }

    }
    head = head->next;
    ps->next = NULL;
    return head;
}

int program()// 程序
{
    if (out_statement())
        return 1;
}
int out_statement()//外部声明
{
    if (func_def())
        return 1;
}
int func_def()//函数定义
{
    a = new SYNBL;
    s.push_back(a);
    b = new PFINFL;
    if (!type_explanation())
    {
        cout << "error1";
        exit(0);
    }
    //填写部分函数表
    s.back()->cat = "f";//函数
    s.back()->p = b;//函数地址
    //pf->push_back(b); //函数表
    b->Level = lv; //函数层数
    if (!p->a.compare("i"))//是否为标识符
    {
        s.back()->name = i[p->num];//函数名
        cout << s.back()->name << " " << s.back()->typ << " " << s.back()->cat << endl;
        p = p->next;
    }
    else if (p->a == "k" && p->num == 1)//是否为标识符
    {
        s.back()->name = "main";//函数名
        //cout << s.back()->name << " " << s.back()->typ << " " << s.back()->cat << endl;
        //cout << a->name << " " << a->typ << " " << a->cat << endl;
        p = p->next;
    }
    else { 
        cout << "error2";
        exit(0);
    }
    if (strcmp(pa[p->num], "("))
    {
        cout << "error3";
        exit(0);
    }
    //函数声明();
    p = p->next;
    if (strcmp(pa[p->num], ")"))
    {
        cout << "error4";
        exit(0);
    }
    p = p->next;
    if (strcmp(pa[p->num], "{"))
    {
        cout << "error5";
        exit(0);
    }
    p = p->next;
    complex_sentence();
    if (strcmp(pa[p->num],"}"))
    {
        cout << "error6";
        exit(0);
    }
    else return 1;
}
int type_explanation()//类型说明
{
    int n=0;
    //a->prior = a;
    a->next = new SYNBL;
    a = a->next;
    a->next = NULL;
    s.push_back(a);
    if (p->a == "k")
    {
        if (!strcmp("void", key[p->num]))
            n = 1;
        else if (!strcmp("int", key[p->num]))
            n = 2;
        else if (!strcmp("char", key[p->num]))
            n = 3;
        else if (!strcmp("float", key[p->num]))
            n = 4;
        switch (n) {
        case 1:s.back()->typ = "void"; break;
        case 2:s.back()->typ = "int"; break;
        case 3:s.back()->typ = "char"; break;
        case 4:s.back()->typ = "float"; break;
        default: return 0;
        }
        p = p->next;
        return 1;
    }
    else
        return 0;
}
int complex_sentence()//复合语句
{
        if (!statement_list())
            sentence_list();
        return 1;
}
int sentence_list()//语句列表
{
    if (!sentence())
        return 0;
    if (sentence_list1())
        return 1;
    else return 0;
}
int sentence_list1()
{
    if (sentence_list())
        return 1;
    else return 0;
}
int statement_list()//声明列表
{
    if (!type_explanation())
        return 0;
    statement();
    if (!pw(";"))
    {
        cout << "error9";
        exit(0);
    }
    statement_list1();//是否要return
}
int statement_list1()//声明列表1
{
    if (!statement_list())
        return 0;
}
int statement()//声明
{
    if (!direct_description())
        return 0;
    return 1;
}
int direct_description()//直接说明符
{
    if (p->a.compare("i") != 0) //不是标识符
    {
        cout << "error10";
        exit(0);
    }
    s.back()->name = i[p->num];//填写名称
    s.back()->cat = "v";//填写种类
    //cout << s.back()->name << " " << s.back()->typ << " " << s.back()->cat << endl;
   // cout << a->name << " " << a->typ << " " << a->cat << endl;
    p = p->next;
    if (!direct_description1())
        return 0;
    return 1;
}
int direct_description1()//直接说明符1
{
    if (pw("["))
    {
        //s.back()->typ = a->prior->typ;
        //s.back()->name=p();填写符号表变量名，需要vector，但是似乎不用在这里填写
        s.back()->cat = "a";
        //填写数组表
        if (p->a == "con")//填写数组表
            p = p->next;
       // exit(0);
        if (!pw("]"))
        {
            cout << "error11";
            exit(0);
        }
        if (!direct_description1())   
            return 0;
        else
            return 1;
    }
    if (pw(","))//下一个字符为,
    {
        
        //开辟总表下一个空间和vector下一空间
        a->next = new SYNBL;
        s.push_back(a->next);
        s.back()->typ = a->typ;
        //a->prior = a;是否还需要
        a = a->next;
        a->next = NULL;

        //准备填表
        if (p->a.compare("i") != 0) //不是标识符
        {
            cout << "error12";
            exit(0);
        }
        //如果是标识符
        s.back()->name = i[p->num];//填写名称  //填写符号表变量名，需要vector
        s.back()->cat = "v";//填写种类   
        //cout << s.back()->name << " " << s.back()->typ << " " << s.back()->cat << endl;
        //cout << a->name << " " << a->typ << " " << a->cat << endl;
        p = p->next;
        if (!direct_description1())
            return 0;
        else
            return 1;
    }
    return 0;
}
int sentence()//语句
{
    if (give()  )
        return 1;
    else
        return 0;
}

int give()//赋值表达式
{
    if (p->a.compare("i") != 0)
        return 0;
    p = p->next;
    if (!pw("="))
    {
        cout << "error13" << endl;
        exit(0);
    }
    if (PLUS())
    {
        if(pw(";"))
        return 1;
    }
    else
    {
        cout << "error14" << endl;
        exit(0);
    }

}
int PLUS()
{
    if (!TIMES())
        return 0;
    if (!PLUS1())//错误
        return 0;
    return 1;
}
int PLUS1()
{
    if (pw("+"))
    {
        if (!TIMES())
            exit(0);
        if (!PLUS1())
            exit(0);
        return 1;
    }
    else if (pw("-"))
    {
        if (!TIMES())
            exit(0);
        if (!PLUS1())
            exit(0);
        return 1;
    }
    else return 1;
}
int TIMES()
{
    if (!BASE())
        return 0;
    if (!TIMES1())
        return 0;
    return 1;
}
int TIMES1()
{
    if (pw("*"))
    {
        if (!BASE())
            exit(0);
        if (!TIMES1())
            exit(0);
        return 1;
    }
    else if (pw("/"))
    {
        if (!BASE())
            exit(0);
        if (!TIMES1())
            exit(0);
        return 1;
    }
    else if (pw("%"))
    {
        if (!BASE())
            exit(0);
        if (!TIMES1())
            exit(0);
        return 1;
    }
    else return 1;
}
int BASE()
{
    if (is_icon())
        return 1;
    if (!p->a.compare("con"))
    {
        p = p->next;
        return 1;
    }
    //if (字符串())
    //    return 1;
    if (pw("("))
    {
        if (!PLUS())
            exit(0);
        if (!pw(")"))
            exit(0);
        return 1;
    }
    else
    {
        cout << "error15" << endl;
        exit(0);
    }
    return 0;
}
int is_icon()
{
    int j = 1;
    if (!p->a.compare("i"))
    {
        while (s[j - 1] != s.back())
        {
            if (!s[j]->name.compare(i[p->num]) && !s[j]->typ.compare("int"))
            {
                p = p->next;
                return 1;
            }
            j++;
        }
        return 0;
    }
    else
        return 0;
}
int pw(string b)
{
    string a;
    if (p->a.compare("p") != 0)
        return 0;
    else 
    {
        if (!b.compare(pa[p->num]))
        {
            p = p->next;
            return 1;
        }
        else return 0;
    }
}
void print()
{
    int i = 1;
    while (s[i] != s.back())
    {
        cout << s[i]->name << " " << s[i]->typ << " " << s[i]->cat << endl;
        i++;
    }
}